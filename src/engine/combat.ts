import type { GameState, Actor } from './types'
import { mulberry32, int } from './rng'
function weaponMeta(state:GameState){ const id=state.player.equipped.weapon; const wep=state.player.inventory.find(i=>('type'in i)&&i.type==='weapon'&&i.id===id) as any; return wep?.meta||{ammo:6,cast:0.3,cd:0.7,dmg:[6,9]} }
export function queuePlayerAttack(state:GameState,targetId?:string){ const now=state.world.time; (state as any)._playerCastUntil=now+0.3; (state as any)._playerCooldownUntil=now+1.0; (state as any)._playerTargetId=targetId }
export function processTick(state:GameState){ const rng=mulberry32(state.seed+state.world.time+state.rollIndex++);
  const castUntil=(state as any)._playerCastUntil as number|undefined
  const cdUntil=(state as any)._playerCooldownUntil as number|undefined
  if(castUntil && castUntil<=state.world.time){ const t=selectTarget(state,(state as any)._playerTargetId); if(t&&state.player.ammo.revolver>0){ const hit=rollToHit(rng,55+state.player.marksmanship*3,t.evasion); if(hit){ const dmg=int(rng,6,9); t.hp=Math.max(0,t.hp-dmg); state.log.push(`[T+${state.world.time}] You hit ${t.id} for ${dmg}. (${t.hp}/${t.maxHp})`) } else { state.log.push(`[T+${state.world.time}] Your shot misses ${t?.id??'the dust'}.`) } state.player.ammo.revolver-=1 } else if(state.player.ammo.revolver<=0){ state.log.push(`[T+${state.world.time}] *Click.* Out of rounds.`) } (state as any)._playerCastUntil=undefined }
  if(cdUntil && cdUntil<=state.world.time){ (state as any)._playerCooldownUntil=undefined }
  for(const a of state.room.actors){ if(a.hp<=0) continue; const wants=a.ai==='sniper'? state.world.time%2===0 : state.world.time%3===0; if(wants){ const hit=rollToHit(rng,a.acc,5); if(hit){ const dmg=int(rng,a.dmg[0],a.dmg[1]); state.player.hp=Math.max(0,state.player.hp-dmg); state.log.push(`[T+${state.world.time}] ${a.id} hits you for ${dmg}. (HP ${state.player.hp}/${state.player.maxHp})`) } else state.log.push(`[T+${state.world.time}] ${a.id} misses.`) } }
  const before=state.room.actors.length; state.room.actors=state.room.actors.filter(a=>a.hp>0); if(state.room.actors.length!==before) state.log.push(`[T+${state.world.time}] An enemy drops.`); if(state.room.actors.length===0 && state.encounter?.active) endEncounter(state,true)
}
function rollToHit(rng:()=>number, acc:number, ev:number){ const dc=50+ev; const roll=acc+Math.floor(rng()*21)-10; return roll>=dc }
export function selectTarget(state:GameState, pref?:string):Actor|undefined{ if(pref) return state.room.actors.find(a=>a.id===pref); return state.room.actors[0] }
export function endEncounter(state:GameState, success:boolean){ const enc=state.encounter; if(!enc) return; enc.active=false; const d=enc.difficulty; if(success){ const coin=5*(d+1)+Math.floor(Math.random()*4); state.player.coin+=coin; state.town.prosperity+=1+d; state.log.push(`Success. +${coin} coin. Prosperity is now ${state.town.prosperity}.`) } else { state.log.push(`Retreat. You live to fight again.`) } }